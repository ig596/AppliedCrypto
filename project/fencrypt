#!/usr/bin/env python3

import binascii
import functools
import hashlib
import hmac
import json
import os
import pathlib
import secrets
import sys
import typing
import unicodedata
import Crypto.Cipher.AES
import Crypto.Util.Counter
import Crypto.Util.Padding
import regex as re
import fencrypt_api
import warnings
warnings.filterwarnings("ignore")

def xor(*args: bytes) -> bytes:
    return bytes(functools.reduce(lambda a, b: a ^ b, i) for i in zip(*args))


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])



def generate_master_key(password: typing.ByteString,
                        salt: typing.ByteString == secrets.token_bytes(16)) -> typing.ByteString:
    source_key = hashlib.pbkdf2_hmac(hash_name='sha256', password=bytes(password, 'utf8'), salt=salt,
                                     iterations=250000, dklen=32)
    return binascii.hexlify(source_key).decode('utf-8')


def generate_keys(source_key) -> typing.Dict:
    converted_source_key = binascii.unhexlify(source_key)
    master_key = converted_source_key[0:16]
    starting_ctr = converted_source_key[16:32]
    keys = {}
    ctr = Crypto.Util.Counter.new(nbits=(8 * 16), initial_value=int.from_bytes(starting_ctr, byteorder='big'))
    context = Crypto.Cipher.AES.new(key=master_key, mode=Crypto.Cipher.AES.MODE_CTR, counter=ctr)
    keys['validator'] = context.encrypt(plaintext=b'\x00' * 16).hex()
    keys['feistel'] = [context.encrypt(plaintext=b'\x00' * 16).hex() for i in range(1, 5)]
    keys['mac'] = context.encrypt(plaintext=b'\x00' * 16).hex()
    keys['search_terms'] = context.encrypt(plaintext=b'\x00' * 16).hex()
    return keys


def aes_ctr_round(key, data: bytes):
    left = binascii.unhexlify(data)[:16]
    right = binascii.unhexlify(data)[16:]
    context = Crypto.Cipher.AES.new(binascii.unhexlify(key), mode=Crypto.Cipher.AES.MODE_CTR, initial_value=left,
                                    nonce=b'')
    keystream = context.encrypt(b'\x00' * len(data))

    return (left.hex() + xor(keystream, right).hex())


def hmac_round(key, data) -> str:
    left = binascii.unhexlify(data)[:16]
    right = binascii.unhexlify(data)[16:]
    mac = hmac.new(key=binascii.unhexlify(key), msg=right, digestmod='sha256')
    return (xor_bytes(left, mac.digest()).hex() + right.hex())


def feistel_all_rounds_encrypt(keys: list, plaintext) -> str:
    if type(plaintext)==str:
        plaintext = bytes(plaintext,'utf-8').hex()
    else:
        plaintext=plaintext.hex()
    round_1 = aes_ctr_round(keys[0], plaintext)
    round_2 = hmac_round(keys[1], round_1)
    round_3 = aes_ctr_round(keys[2], round_2)
    round_4 = hmac_round(keys[3], round_3)
    return round_4


def feistel_all_rounds_decrypt(keys: list, ciphertext: bytes) -> str:
    round_1 = hmac_round(keys[3], ciphertext)
    round_2 = aes_ctr_round(keys[2], round_1)
    round_3 = hmac_round(keys[1], round_2)
    round_4 = aes_ctr_round(keys[0], round_3)
    return round_4


def parse_text_for_search_words(text) -> list:
    pattern = re.compile(r"(?<![^\W])((\w){4,12})(?![^\W])", flags=re.UNICODE + re.WORD + re.VERSION1)
    terms = re.findall(pattern, string=text)
    terms = sorted(list(set([term[0] for term in terms])))
    return terms


def tokenize_terms(terms: list):
    search_tokens = []
    for term in terms:
        search_tokens.append(unicodedata.normalize('NFC', term).casefold())
        temp = [unicodedata.normalize('NFC', term[0:i] + '*').casefold() for i in range(4, len(term))]
        search_tokens = search_tokens + temp
    groomed = sorted(list(set(search_tokens)))
    return groomed


def full_ecrypt_process(password: str, file: str, output:bool):
    salt = secrets.token_bytes(16)
    master_key = generate_master_key(password, salt)
    feistel_keys = generate_keys(master_key)

    open_file = open(file, 'rb')
    content = open_file.read()
    try:
        if type(content)!=str:
            content = content.decode("utf8")
        terms = parse_text_for_search_words(content)
        tokens = tokenize_terms(terms)
        # print(len(tokens))
        tokens= [hmac.new(key=bytes.fromhex(feistel_keys['mac']),msg=bytes(token,'utf8'),digestmod=hashlib.sha256).hexdigest() for token in tokens]
    except UnicodeDecodeError as ude:
        terms = None
        tokens = hmac.new(key=bytes.fromhex(feistel_keys['mac']),msg=b'',digestmod=hashlib.sha256).hexdigest()
    open_file.close()
    mac_key = bytes.fromhex(feistel_keys['mac'])
    path = pathlib.Path(file)
    metadata=create_metadata(path=path.parent, file_name=path.name, salt=salt.hex(), validator=master_key,
                    terms=tokens,
                    mac=hmac.new(mac_key, content, hashlib.sha256).hexdigest())
    if output:
        json.dump(metadata, sys.stdout)
    encrypted_file = open(file, 'wb+')
    encrypted_content = feistel_all_rounds_encrypt(feistel_keys['feistel'], content)
    encrypted_content = bytes.fromhex(encrypted_content)
    encrypted_file.write(encrypted_content)
    encrypted_file.close()



def full_decyrpt_process(password, file):
    metadata=get_metadata(file)
    if  generate_master_key(password,metadata['salt'])==metadata['validator']:
        encrypted_file=open(file,'rb')
        encrypted_content=encrypted_file.read()
        decrypted_content=feistel_all_rounds_decrypt(metadata['feistel'],encrypted_content)
        encrypted_file.close()
        decrcrypted_file=open(file,'wb')
        decrcrypted_file.write(decrypted_content)
        decrcrypted_file.close()
        if os.path.exists(f'.fenc-metadata.{file}'):
            os.remove(file,f'.fenc-metadata.{file}')

def get_metadata(original_file_name):
    with open(f'.fenc-metadata.{original_file_name}', 'r') as metadata_file:
        return json.load(metadata_file)

def create_metadata(path, file_name, salt, validator, mac, terms):
    with open(f'{path}/.fenc-metadata.{file_name}', 'w') as metadata_file:
        metadata = {"salt": salt, "validator": validator, "mac": mac, "terms": terms}
        # print(metadata)
        json.dump(metadata, metadata_file)
        return metadata
def validate_password(password,file):
    metadata=get_metadata(file)
    if generate_master_key(password,metadata['salt'])==metadata['validator']:
        return True
    else:
        return False
if __name__ == "__main__":
    warnings.filterwarnings("ignore")
    args = fencrypt_api.arg_setup()
    if args.encrypt:
        for file in args.files:
            password = fencrypt_api.get_password()
            full_ecrypt_process(password, file,output=True)
            # print(get_metadata(file))
    elif args.decrypt:
        for file in args.files:
            password = fencrypt_api.get_password()
            if validate_password(password,file):
                if args.json_out:
                    print(get_metadata(file))
                full_decyrpt_process(password,file)
